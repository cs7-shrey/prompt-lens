generator client {
  provider     = "prisma-client"
  output       = "../generated"
  moduleFormat = "esm"
  runtime      = "bun"
}

datasource db {
  provider = "postgresql"
}

enum AISource {
  CHATGPT
  CLAUDE
  PERPLEXITY
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum AnalyticsStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum Sentiment {
  positive
  negative
  neutral
}

model Competitor {
  id   String @id @default(uuid())
  name String
  url  String

  trackingCompanyId String
  trackingCompany   TrackingCompany @relation(fields: [trackingCompanyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([url])
}

model TrackingCompany {
  id   String @id @default(uuid())
  name String
  url  String

  shortDescription String?
  fullDescription  String?
  industry         String?
  keyFeatures      String[]

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  monitors    Monitor[]
  competitors Competitor[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([url])
  @@unique([userId]) // for now, only one tracking company per user
}

model Prompt {
  id      String @id @default(uuid())
  content String

  monitorId String
  monitor   Monitor @relation(fields: [monitorId], references: [id], onDelete: Cascade)

  responses Response[]
  jobs      Job[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Response {
  id        String   @id @default(uuid())
  content   String
  citations String[] @default([])
  analyticsStatus AnalyticsStatus @default(PENDING)

  aiSource AISource

  promptId String
  prompt   Prompt @relation(fields: [promptId], references: [id], onDelete: Cascade)

  mentions Mention[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  analysedAt DateTime?
}

model Monitor {
  id   String @id @default(uuid())
  name String

  aiSources AISource[] @default([CHATGPT, CLAUDE, PERPLEXITY])
  prompts   Prompt[]

  trackingCompanyId String
  trackingCompany   TrackingCompany @relation(fields: [trackingCompanyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  updatedAt DateTime @updatedAt

  @@unique([trackingCompanyId]) // for now, only one monitor per tracking company
}

model Job {
  id       String   @id @default(uuid())
  aiSource AISource

  promptId String
  prompt   Prompt @relation(fields: [promptId], references: [id], onDelete: Cascade)

  responseId String?

  status JobStatus

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([promptId, aiSource, status])
}

model Brand {
  id            String   @id @default(uuid())
  canonicalName String
  displayName   String
  category      String?
  websiteUrl    String?
  aliases       String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mentions Mention[]

  @@unique([canonicalName])
  @@unique([displayName])
  @@unique([websiteUrl])
  @@index([canonicalName])
  @@index([aliases], type: Gin)
}

model Mention {
  id        String    @id @default(uuid())
  position  Int
  sentiment Sentiment
  mentionScore Float

  responseId String
  response   Response @relation(fields: [responseId], references: [id], onDelete: Cascade)

  brandId String
  brand   Brand  @relation(fields: [brandId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([responseId])
  @@index([brandId])
}
